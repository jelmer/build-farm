# -*- mode: shell-script; sh-indentation: 8; indent-tabs-mode: t; -*-

# build_farm -- distributed build/test architecture for samba, rsync, etc

# Copyright (C) 2001 by Andrew Tridgell <tridge@samba.org>
# Copyright (C) 2001 by Andrew Bartlett <abartlet@samba.org>
# Copyright (C) 2001, 2003 by Martin Pool <mbp@samba.org>

# default maximum runtime for any command
MAXTIME=7200
RUN_FROM_BUILD_FARM=yes
export RUN_FROM_BUILD_FARM

#############################
# build a signature of a tree, used to see if we
# need to rebuild 
sum_tree() {
        sum_tree_test_root=$1
	sum_tree_tree=$2
	sum_tree_sum=$3
	find $sum_tree_test_root/$sum_tree_tree -type f -print | grep -v '.svn' | grep -v version.h | sort | xargs sum > $sum_tree_sum
	sum build_test build_test.fns >> $sum_tree_sum

	if [ -f "$host.fns" ]; then
	    sum $host.fns >> $sum_tree_sum
	else
            sum generic.fns >> $sum_tree_sum
	fi
}

#############################
# send the logs to the master site
send_logs() {
	if [ "$nologreturn" = "yes" ]; then
		echo "skipping log transfer"
	else
		log="$1"
		err="$2"
		chmod 0644 "$log" "$err"
		rsync -q --password-file=.password -cz --timeout=200 \
			"$log" "$err" $host@samba.org::build_farm_data/
	fi
}

############################
# fetch the latest copy of the tree
fetch_tree() {
	if [ "$norsync" = "yes" ]; then
		echo "skipping tree transfer"
	else
		tree=$1
		if rsync --exclude=autom4te.cache/ --exclude=.svn/ --delete-excluded -q --partial --timeout=200 -crlpz --delete --ignore-errors \
			samba.org::ftp/unpacked/$tree/ $test_root/$tree; then
			echo "transferred $tree OK"
		else
			echo "transfer of $tree failed code $?"
			return 1
		fi
	fi
	return 0
}

############################
# fetch the latest copy of the svn entries file
fetch_svn() {
    tree=$1
# skip products still in CVS.
    case "$tree" in
    ccache | distcc | rsync)
        return 1
        ;;
    *)
        ;;
    esac
    if [ "$norsync" = "yes" ]; then
	echo "skipping svn transfer"
    else
	if [ -r $test_root/$tree.svn ]; then
		rm -f $test_root/$tree.svn.old
	    mv $test_root/$tree.svn $test_root/$tree.svn.old
	fi
	rsync -q --timeout=200 -clz --ignore-errors \
	    samba.org::ftp/unpacked/$tree/.svn/entries $test_root/$tree.svn
    fi
    if [ -r $test_root/$tree.svn ]; then
	return 0;
    fi
    return 1
}

############################
# grab a lock file. Not atomic, but close :)
# tries to cope with NFS
lock_file() {
	lck="$1"
	machine=`cat "$lck" 2> /dev/null | cut -d: -f1`
	pid=`cat "$lck" 2> /dev/null | cut -d: -f2`

	if [ -f "$lck" ] && 
	    ( [ $machine != $host ] || kill -0 $pid ) 2> /dev/null; then
		echo "lock file $lck is valid for $machine:$pid"
		return 1
	fi
	/bin/rm -f "$lck"
	echo "$host:$$" > "$lck"
	return 0
}

############################
# unlock a lock file
unlock_file() {
	lck="$1"
	/bin/rm -f "$lck"
}

############################
# run make, and print trace
do_make() {

  if [ x"$MAKE" = x ] 
  then
    MAKE=make
  fi 
    
  for t in $*; do
    if [ x"$BUILD_FARM_NUM_JOBS" = x ]; then
      echo "$MAKE $t"
      ./timelimit $MAXTIME "$MAKE" "$t"
      status=$?
    else
      # we can parallelize everything and all targets
      if [ x"$t" = xeverything ] || [ x"$t" = xall]; then
        echo "$MAKE" "-j$BUILD_FARM_NUM_JOBS"  "$t"
        ./timelimit $MAXTIME "$MAKE" "-j$BUILD_FARM_NUM_JOBS"  "$t"
        status=$?
      else
        echo "$MAKE $t"
        ./timelimit $MAXTIME "$MAKE" "$t"
        status=$?
      fi
    fi

    if [ $status != 0 ]; then
      return $status;
    fi

  done

  return 0
}      

############################
# configure the tree
action_configure() {
        if [ ! -x configure ]; then
	    ls -l configure
	    ./autogen.sh
	fi
	echo "CFLAGS=$CFLAGS"
	echo configure options: $config_and_prefix
	echo CC="$CCACHE $compiler" $srcdir/configure $config_and_prefix
	CC="$CCACHE $compiler"
	export CC
	./timelimit $MAXTIME $srcdir/configure $config_and_prefix
	cstatus=$?
	echo "CONFIGURE STATUS: $cstatus"
	if [ $cstatus != 0 ]; then
	    echo "contents of config.log:"
	    cat config.log
	fi
	return $cstatus;
}

############################
# build the tree
action_build() {
	case "$tree" in
	samba4)
		# the 2nd 'make everything' is to work around a bug
		# in netbsd make. 
		do_make proto showflags everything
		do_make everything
		if [ -n "$smbtorture4" ]; then
		    if [ -f bin/smbtorture ]; then
		    	if [ -f $smbtorture4 ]; then
			    rm $smbtorture4
			fi
			cp bin/smbtorture $smbtorture4
		    fi
		fi
		;;
	samba|samba_3_0)
	    do_make proto everything torture
	    ;;
	*)
	    do_make all
	    ;;
	esac

	bstatus=$?
	echo "BUILD STATUS: $bstatus"
	return $bstatus
}

############################
# show static analysis results
action_cc_checker() {

	# default to passing the cc_checker
        cccstatus=0

	if [ -f ibm_checker.out ]; then
		cat ibm_checker.out
		cccstatus=`cat ibm_checker.out | grep '^\-\- ' | wc -l`
	fi

	echo "CC_CHECKER STATUS: $cccstatus"
	return $cccstatus;	
}

############################
# install the tree
action_install() {
	if [ -d $prefix ]; then
		if [ "$noclean" != "yes" ]; then
		    rm -rf $prefix
		fi
	fi

	do_make install
	istatus=$?
	echo "INSTALL STATUS: $istatus"
	return $istatus;
}

############################
# test the tree
action_test_samba() {
	do_make test
	totalstatus=$?
	return "$totalstatus"
}

action_test_generic() {
        CC="$compiler"
	export CC
	do_make installcheck
	totalstatus=$?
	echo "TEST STATUS: $totalstatus"
	return "$totalstatus"
}

action_test_lorikeet_heimdal() {
        CC="$compiler"
	export CC
	do_make check
	totalstatus=$?
	echo "TEST STATUS: $totalstatus"
	return "$totalstatus"
}


#############################
# attempt some basic tests of functionaility
# starting as basic as possible, and getting incresingly complex

action_test() {
	# Samba needs crufty code of its own for backward
	# compatiblity.  I think a better way to do this in the future
	# is to just call 'make installcheck'.
	case "$tree" in
	samba*|smb-build)
	    action_test_samba
	    ;;
	lorikeet-heimdal*)
	    action_test_lorikeet_heimdal
	    ;;
	*)
	    action_test_generic
	    ;;
	esac
}

###########################
# do a test build of a particular tree
test_tree() {
	tree=$1
	source=$2
	compiler="$3"
	shift
	shift
	shift
	if [ "$compiler" = "gcc" ] && [ "$tree" != "ccache" ] && ccache -V > /dev/null; then
	    CCACHE="ccache"
	    export CCACHE
	else
	    CCACHE=""
	fi

	# limit our resource usage
	ulimit -t $MAXTIME
	ulimit -m 100000

	# Keep stuff private
	umask 077

	if [ -z "$test_root" ]; then
		test_root=`pwd`
	fi

	log="build.$tree.$host.$compiler.log"
	err="build.$tree.$host.$compiler.err"
	sum="build.$tree.$host.$compiler.sum"
	lck="$test_root/build.$tree.lck"
        srcdir="$test_root/$tree/$source"

	case "$tree" in
	    tdb | talloc | ldb)
		builddir=$srcdir/tmpbuild
		export builddir
	    ;;
	    *)
		builddir=$srcdir
		export builddir
	    ;;
	esac

	if ! lock_file "$lck"; then
		return
	fi

	# pull the svn entries, if any
	if fetch_svn "$tree"; then
	    rm -f $test_root/$tree.$compiler.svn.old
	    mv $test_root/$tree.$compiler.svn $test_root/$tree.$compiler.svn.old
	    cp $test_root/$tree.svn $test_root/$tree.$compiler.svn
	    if cmp $test_root/$tree.$compiler.svn $test_root/$tree.$compiler.svn.old > /dev/null; then
		echo "skip: $tree.$compiler nothing changed in svn"
		touch "$log" "$err"
		send_logs "$log" "$err"
		unlock_file "$lck"
		return
	    fi
	fi

	# pull the tree
	if ! fetch_tree "$tree"; then
	    unlock_file "$lck"
	    return
	fi

        if [ ! -x $srcdir/configure ]; then
		echo "skip: $tree.$compiler configure not present, try again next time!"
		unlock_file "$lck"
		return
	fi

	if [ ! $USER = "" ]; then
	    whoami=$USER
	else 
	    if [ ! $LOGNAME = "" ]; then
		whoami=$LOGNAME
	    else
		whoami=build
	    fi
	fi

	prefix="$test_root/prefix"
	if [ ! -d $prefix ]; then
		mkdir $prefix
	fi
	prefix="$prefix/$tree"

	smbtorture4=$test_root/smbtorture4
	export smbtorture4

	case "$tree" in
	samba4)
	    config="$config --enable-socket-wrapper"
	    ;;
	samba|samba_3_0)
	    config="$config --enable-socket-wrapper"
	    if [ -f $smbtorture4 ]; then
	        # we create a local copy to make sure the same binary is used for all tests
	    	cp $smbtorture4 $smbtorture4.$tree 
		config="$config --with-smbtorture4-path=$smbtorture4.$tree"
	    fi
	    ;;
	*)
	    testsuite=testsuite
	    ;;
	esac

	config_and_prefix="$config --prefix=$prefix"

	# see if we need to rebuild
	sum_tree $test_root $tree $sum
	echo "CFLAGS=$CFLAGS $config_and_prefix" >> $sum

	if cmp "$sum" "$sum.old" > /dev/null; then
		echo "skip: $tree.$compiler nothing changed"
		touch "$log" "$err"
		send_logs "$log" "$err"
		unlock_file "$lck"
		return
	fi

	# we do need to rebuild - save the old sum
	/bin/rm -f $sum.old
	mv $sum $sum.old

	actions="$*"
	
	if [ "$actions" = "" ]; then
	    actions="configure build install test"
	fi

	# start the build
	(
		uname -a

                # we need to be able to see if a build farm machine is accumulating
                # stuck processes. We do this in two ways, as we don't know what style
                # of ps it will have
		ps xfuw 2> /dev/null
		ps -fu $USER 2> /dev/null

		echo "building $tree with CC=$compiler on $host at "`date`

           	# build the timelimit utility
		echo "Building timelimit"
		mkdir -p $builddir
		$compiler $TIMELIMIT_FLAGS -o $builddir/timelimit $test_root/timelimit.c || exit 1

		if [ -r $test_root/$tree.svn ]; then
		  h_rev=`grep revision= $test_root/$tree.svn | head -1 | cut -d'"' -f2`
		  if [ -n "$h_rev" ]; then
			echo "HIGHEST SVN REVISION: $h_rev"
		  fi
		  rev=`grep committed-rev= $test_root/$tree.svn | head -1 | cut -d'"' -f2`
		  if [ -n "$rev" ]; then
			echo "BUILD REVISION: $rev"
		  fi
		fi

		for action in $actions; do

		    echo Running action $action

		    date

		    cd $builddir || exit 1
		    export srcdir
		    df .
		    mount
		    vmstat

		    ( action_$action )
		    action_status=$?
		    
		    if [ $action_status != 0 ]; then
			echo "ACTION FAILED: $action";
		    else
			echo "ACTION PASSED: $action";
		    fi
		    
		    if [ $action_status != 0 ]; then 
			break;
		    fi

		done

		if [ "$noclean" = "yes" ]; then
		    echo cleanup skipped!
		else
		    echo cleaning up
		    do_make clean
		    /bin/rm -rf $prefix
		fi
		date
	) > "$log" 2> "$err"
	
	# send the logs to the master site
	send_logs "$log" "$err"

	# cleanup
	unlock_file "$lck"
}


#########################################################
# enable this on a per host basis only when needed please
# (at least for the moment)
kill_old_processes() {
    # this should work on systems with linux like ps
    (ps uxfw | grep /build | grep -v grep | egrep 'AM|PM|Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec' | awk '{print $2}' | xargs kill -9) 2> /dev/null
    # and this should work on sysv style ps
    (ps -fu $USER | grep /build | grep -v grep | egrep 'AM|PM|Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec' | awk '{print $2}' | xargs kill -9) 2> /dev/null
}


# this is a special fn that allows us to add a "special" hook to the build
# farm that we want to do to the build farm. never leave it empty. instead,
# use ":" as the fn body.
per_run_hook() {
    # kill old processes on systems with a known problem
    case $host in
	nohost)
	    echo "just a placeholder";
	    ;;
    esac
}


######################################################
# main code that is run on each call to the build code
rsync --timeout=200 -q -az samba.org::build_farm/*.c .


# build.log can grow to an excessive size, trim it beyond 50M
if [ -f build.log ]; then
  find build.log -size +100000 -exec /bin/rm '{}' \;
fi

